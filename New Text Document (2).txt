3.Write a C program to implement the Brute Force Technique of Top Down Parsing. 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
char input[100]; 
int inde = 0; 
int error = 0; 
void E(); 
void T(); 
void F(); 
void match(char c) { 
if (input[inde] == c) { 
inde++; 
} else { 
        error = 1; 
    } 
} 
 
void E() { 
    T(); 
    if (input[inde] == '+') { 
        match('+'); 
        E(); 
    } 
} 
 
void T() { 
    F(); 
    if (input[inde] == '*') { 
        match('*'); 
        T(); 
    } 
} 
 
void F() { 
    if (input[inde] == '(') { 
        match('('); 
        E(); 
        match(')'); 
    } else if (input[inde] == 'i') { 
        match('i'); 
    } else { 
        error = 1; 
} 
} 
int main() { 
printf("Enter an arithmetic expression: "); 
fgets(input, 100, stdin); 
// Remove newline character 
input[strcspn(input, "\n")] = '\0'; 
E(); 
if (error == 0 && inde == strlen(input)) { 
printf("Valid expression\n"); 
} else { 
printf("Invalid expression\n"); 
} 
return 0; 
} 
Output: 
Enter an arithmetic expression: (i+i)*i 
Valid expression

10.Write a C program to generate a three  address code for a given expression. 
#include<stdio.h> 
#include<conio.h> 
#include<stdlib.h> 
#include<string.h> 
struct three 
{ 
char data[10],temp[7]; 
}s[30]; 
void main() 
{ 
char d1[7],d2[7]="t"; 
int i=0,j=1,len=0; 
FILE *f1,*f2; 
clrscr(); 
f1=fopen("sum.txt","r"); 
f2=fopen("out.txt","w"); 
while(fscanf(f1,"%s",s[len].data)!=EOF) 
len++; 
itoa(j,d1,7); 
strcat(d2,d1); 
strcpy(s[j].temp,d2); 
strcpy(d1,""); 
strcpy(d2,"t"); 
if(!strcmp(s[3].data,"+")) 
{ 
fprintf(f2,"%s=%s+%s",s[j].temp,s[i+2].data,s[i+4].data); 
j++; 
} 
else if(!strcmp(s[3].data,"-")) 
{ 
fprintf(f2,"%s=%s-%s",s[j].temp,s[i+2].data,s[i+4].data); 
j++; 
} 
for(i=4;i<len-2;i+=2) 
{ 
itoa(j,d1,7); 
strcat(d2,d1); 
strcpy(s[j].temp,d2); 
if(!strcmp(s[i+1].data,"+")) 
fprintf(f2,"\n%s=%s+%s",s[j].temp,s[j-1].temp,s[i+2].data); 
else if(!strcmp(s[i+1].data,"-")) 
fprintf(f2,"\n%s=%s-%s",s[j].temp,s[j-1].temp,s[i+2].data); 
strcpy(d1,""); 
strcpy(d2,"t"); 
j++; 
} 
fprintf(f2,"\n%s=%s",s[0].data,s[j-1].temp); 
fclose(f1); 
fclose(f2); 
getch(); 
} 
Input:  sum.txt 
out = in1 + in2 + in3 - in4 
Output  :       
t1=in1+in2 
t2=t1+in3 
t3=t2-in4 
out=t3 
out.txt

8 .Write a C program for implementation of a Shift Reduce Parser using Stack Data Structure to accept a 
given input string of a given grammar. 
 
#include<stdio.h> 
#include<string.h> 
int k=0,z=0,i=0,j=0,c=0; 
char a[16],ac[20],stk[15],act[10]; 
void check(); 
int main() 
   { 
 
      puts("GRAMMAR is E->E+E \n E->E*E \n E->(E) \n E->id"); 
      puts("enter input string "); 
      gets(a); 
      c=strlen(a); 
      strcpy(act,"SHIFT->"); 
      puts("stack \t input \t action"); 
      for(k=0,i=0; j<c; k++,i++,j++) 
       { 
         if(a[j]=='i' && a[j+1]=='d') 
           { 
              stk[i]=a[j]; 
              stk[i+1]=a[j+1]; 
              stk[i+2]='\0'; 
              a[j]=' '; 
              a[j+1]=' '; 
              printf("\n$%s\t%s$\t%sid",stk,a,act); 
              check(); 
           } 
         else 
           { 
              stk[i]=a[j]; 
              stk[i+1]='\0'; 
              a[j]=' '; 
              printf("\n$%s\t%s$\t%ssymbols",stk,a,act); 
              check(); 
           } 
       } 
 
   } 
   void check() 
   { 
     strcpy(ac,"REDUCE TO E"); 
     for(z=0; z<c; z++) 
       if(stk[z]=='i' && stk[z+1]=='d') 
         { 
           stk[z]='E'; 
           stk[z+1]='\0'; 
           printf("\n$%s\t%s$\t%s",stk,a,ac); 
           j++; 
         } 
         for(z=0; z<c; z++) 
       if(stk[z]=='E' && stk[z+1]=='*' && stk[z+2]=='E') 
         { 
           stk[z]='E'; 
           stk[z+1]='\0'; 
           stk[z+1]='\0'; 
           printf("\n$%s\t%s$\t%s",stk,a,ac); 
           i=i-2; 
         } 
        for(z=0; z<c; z++) 
       if(stk[z]=='(' && stk[z+1]=='E' && stk[z+2]==')') 
         { 
           stk[z]='E'; 
           stk[z+1]='\0'; 
           stk[z+1]='\0'; 
           printf("\n$%s\t%s$\t%s",stk,a,ac); 
           i=i-2; 
         } 
   } 
 
Output: 
/tmp/rVDYCnu0I4.o 
GRAMMAR is E->E+E  
 E->E*E  
 E->(E)  
 E->id 
enter input string  
id+id\id+id 
 
stack         input                 action 
 
$id   +id\id+id$       SHIFT->id 
$E   +id\id+id$       REDUCE TO E 
$E+    id\id+id$      SHIFT->symbols 
$E+id      \id+id$      SHIFT->id 
$E+E      \id+id$     REDUCE TO E 
$E+E\       id+id$     SHIFT->symbols 
$E+E\id         +id$     SHIFT->id 
$E+E\E         +id$     REDUCE TO E 
$E+E\E+        id$                   SHIFT->symbols 
$E+E\E+id       $        SHIFT->id 
$E+E\E+E        $     REDUCE TO E 
 
 
 
 
9.Simulate the calculator using LEX and YACC tool. 
Lexfile.l 
 
%option noinput nounput noyywrap 
%{ 
#include <stdlib.h> 
#include <stdio.h> 
#include "y.tab.h" 
extern int yylval; 
%} 
 
%% 
 
[\t]      ; 
[\n]      return 0; 
 
[0-9]+    { yylval = atoi(yytext); 
            return num; 
          } 
.         
return yytext[0]; 
%% 
File.y 
%{ 
#include <ctype.h> 
#include <stdio.h> 
int yylex(); 
void yyerror(); 
int tmp=0; 
%} 
%token num 
%left '+' '-' 
%left '*' '/' 
%left '(' ')' 
%% 
line :exp  {printf("=%d\n",$$); return 0;}; 
exp  :exp '+' exp {$$ =$1+$3;} 
| exp '-' exp {$$ =$1-$3;} 
| exp '*' exp {$$ =$1*$3;} 
| exp '/' exp {$$ =$1/$3;} 
| '(' exp ')' {$$=$2;} 
| num {$$=$1;}; 
%% 
void yyerror(){ 
printf("The arithmetic expression is correct\n"); 
tmp=1; 
} 
int main(){ 
printf("Enter an arithmetic expression(can contain +,-,*,/ or parenthesis):\n"); 
yyparse(); 
} 
Output: 
To run lexfile.l the command is: 
lex lexfile.l 
To run file.y the command is: 
yacc -d file.y 
gcc -o output lex.yy.c y.tab.c 
./output 
Enter an arithmetic expression(can contain +,-,*,/ or parenthesis): 
a+b 
The arithmetic expression is correct 

4.Write a C program to implement a Recursive Descent Parser. 
 
#include <stdio.h> 
#include <string.h> 
  
#define SUCCESS 1 
#define FAILED 0 
  
int E(), Edash(), T(), Tdash(), F(); 
  
const char *cursor; 
char string[64]; 
  
int main() 
{ 
    puts("Enter the string"); 
    // scanf("%s", string); 
    sscanf("i+(i+i)*i", "%s", string); 
    cursor = string; 
    puts(""); 
    puts("Input            Action"); 
    puts("--------------------------------"); 
  
    if (E() && *cursor == '\0') { 
        puts("--------------------------------"); 
        puts("String is successfully parsed"); 
        return 0; 
    } else { 
        puts("--------------------------------"); 
        puts("Error in parsing String"); 
        return 1; 
    } 
} 
  
int E() 
{ 
    printf("%-16s E  ->  T E'\n", cursor); 
    if (T()) { 
        if (Edash()) 
            return SUCCESS; 
        else 
            return FAILED; 
    } else 
        return FAILED; 
} 
  
int Edash() 
{ 
    if (*cursor == '+') { 
        printf("%-16s E' ->  + T E'\n", cursor); 
        cursor++; 
        if (T()) { 
            if (Edash()) 
                return SUCCESS; 
            else 
                return FAILED; 
        } else 
            return FAILED; 
    } else { 
        printf("%-16s E' ->  $\n", cursor); 
        return SUCCESS; 
    } 
} 
  
int T() 
{ 
    printf("%-16s T  ->  F T'\n", cursor); 
    if (F()) { 
        if (Tdash()) 
            return SUCCESS; 
        else 
            return FAILED; 
    } else 
        return FAILED; 
} 
  
int Tdash() 
{ 
    if (*cursor == '*') { 
        printf("%-16s T' ->  * F T'\n", cursor); 
        cursor++; 
        if (F()) { 
            if (Tdash()) 
                return SUCCESS; 
            else 
                return FAILED; 
        } else 
            return FAILED; 
    } else { 
        printf("%-16s T' ->  $\n", cursor); 
        return SUCCESS; 
    } 
} 
  
int F() 
{ 
    if (*cursor == '(') { 
        printf("%-16s F  ->  ( E )\n", cursor); 
        cursor++; 
        if (E()) { 
            if (*cursor == ')') { 
                cursor++; 
                return SUCCESS; 
            } else 
                return FAILED; 
        } else 
            return FAILED; 
    } else if (*cursor == 'i') { 
        cursor++; 
        printf("%-16s F  ->  i\n", cursor); 
        return SUCCESS; 
    } else 
        return FAILED; 
} 
Output: 
/tmp/HKzwdTYnft.o 
Enter the string 
Input            Action -------------------------------- 
i+(i+i)*i        E  ->  T E' 
i+(i+i)*i        T  ->  F T' 
+(i+i)*i         F  ->  i 
+(i+i)*i         T' ->  $ 
+(i+i)*i         E' ->  + T E' 
(i+i)*i          T  ->  F T' 
(i+i)*i          F  ->  ( E ) 
i+i)*i           E  ->  T E' 
i+i)*i           T  ->  F T' 
+i)*i            F  ->  i 
+i)*i            T' ->  $ 
+i)*i            E' ->  + T E' 
i)*i             T  ->  F T' 
)*i              F  ->  i 
)*i              T' ->  $ 
)*i              E' ->  $ 
*i               T' ->  * F T' 
                 F  ->  i 
                 T' ->  $ 
                 E' ->  $ -------------------------------- 
String is successfully parsed

1.Write a C program to identify different types of tokens in a given program. 
#include <stdbool.h> 
#include <stdio.h> 
#include <string.h> 
#include <stdlib.h> 
// Returns 'true' if the character is a DELIMITER. 
bool isDelimiter(char ch) 
{ 
if (ch == ' ' || ch == '+' || ch == '-' || ch == '*' || 
ch == '/' || ch == ',' || ch == ';' || ch == '>' || 
ch == '<' || ch == '=' || ch == '(' || ch == ')' || 
ch == '[' || ch == ']' || ch == '{' || ch == '}') 
return (true); 
return (false); 
} 
// Returns 'true' if the character is an OPERATOR. 
bool isOperator(char ch) 
{ 
if (ch == '+' || ch == '-' || ch == '*' || 
ch == '/' || ch == '>' || ch == '<' || 
ch == '=') 
return (true); 
return (false); 
} 
// Returns 'true' if the string is a VALID IDENTIFIER. 
bool validIdentifier(char* str) 
{ 
if (str[0] == '0' || str[0] == '1' || str[0] == '2' || 
str[0] == '3' || str[0] == '4' || str[0] == '5' || 
str[0] == '6' || str[0] == '7' || str[0] == '8' || 
str[0] == '9' || isDelimiter(str[0]) == true) 
return (false); 
return (true); 
} 
// Returns 'true' if the string is a KEYWORD. 
bool isKeyword(char* str) 
{ 
if (!strcmp(str, "if") || !strcmp(str, "else") || 
!strcmp(str, "while") || !strcmp(str, "do") || 
!strcmp(str, "break") || 
!strcmp(str, "continue") || !strcmp(str, "int") 
  || !strcmp(str, "double") || !strcmp(str, "float") 
  || !strcmp(str, "return") || !strcmp(str, "char") 
  || !strcmp(str, "case") || !strcmp(str, "char") 
  || !strcmp(str, "sizeof") || !strcmp(str, "long") 
  || !strcmp(str, "short") || !strcmp(str, "typedef") 
  || !strcmp(str, "switch") || !strcmp(str, "unsigned") 
  || !strcmp(str, "void") || !strcmp(str, "static") 
  || !strcmp(str, "struct") || !strcmp(str, "goto")) 
  return (true); 
 return (false); 
} 
 
// Returns 'true' if the string is an INTEGER. 
bool isInteger(char* str) 
{ 
 int i, len = strlen(str); 
 
 if (len == 0) 
  return (false); 
 for (i = 0; i < len; i++)  
{ 
  if (str[i] != '0' && str[i] != '1' && str[i] != '2' 
   && str[i] != '3' && str[i] != '4' && str[i] != '5' 
   && str[i] != '6' && str[i] != '7' && str[i] != '8' 
   && str[i] != '9' || (str[i] == '-' && i > 0)) 
   return (false); 
 } 
 return (true); 
} 
 
// Returns 'true' if the string is a REAL NUMBER. 
bool isRealNumber(char* str) 
{ 
 int i, len = strlen(str); 
 bool hasDecimal = false; 
 
 if (len == 0) 
  return (false); 
 for (i = 0; i < len; i++)  
{ 
  if (str[i] != '0' && str[i] != '1' && str[i] != '2' 
   && str[i] != '3' && str[i] != '4' && str[i] != '5' 
   && str[i] != '6' && str[i] != '7' && str[i] != '8' 
   && str[i] != '9' && str[i] != '.' || 
   (str[i] == '-' && i > 0)) 
   return (false); 
  if (str[i] == '.') 
   hasDecimal = true; 
 } 
 return (hasDecimal); 
} 
 
// Extracts the SUBSTRING. 
char* subString(char* str, int left, int right) 
{ 
 int i; 
 char* subStr = (char*)malloc( 
    sizeof(char) * (right - left + 2)); 
 
 for (i = left; i <= right; i++) 
  subStr[i - left] = str[i]; 
 subStr[right - left + 1] = '\0'; 
 return (subStr); 
} 
 
// Parsing the input STRING. 
void parse(char* str) 
{ 
 int left = 0, right = 0; 
 int len = strlen(str); 
 
 while (right <= len && left <= right) 
 { 
  if (isDelimiter(str[right]) == false) 
   right++; 
 
  if (isDelimiter(str[right]) == true && left == right) 
          { 
   if (isOperator(str[right]) == true) 
    printf("'%c' IS AN OPERATOR\n", str[right]); 
 
   right++; 
   left = right; 
    } 
else if (isDelimiter(str[right]) == true && left != right 
    || (right == len && left != right))  
{ 
   char* subStr = subString(str, left, right - 1); 
 
   if (isKeyword(subStr) == true) 
    printf("'%s' IS A KEYWORD\n", subStr); 
 
   else if (isInteger(subStr) == true) 
    printf("'%s' IS AN INTEGER\n", subStr); 
 
   else if (isRealNumber(subStr) == true) 
    printf("'%s' IS A REAL NUMBER\n", subStr); 
 
   else if (validIdentifier(subStr) == true 
     && isDelimiter(str[right - 1]) == false) 
    printf("'%s' IS A VALID IDENTIFIER\n", subStr); 
 
   else if (validIdentifier(subStr) == false 
     && isDelimiter(str[right - 1]) == false) 
    printf("'%s' IS NOT A VALID IDENTIFIER\n", subStr); 
   left = right; 
  } 
 } 
 return; 
} 
 
// DRIVER FUNCTION 
int main() 
{ 
 // maximum length of string is 100 here 
 char str[100] = "int a = b + 1c; "; 
 
 parse(str); // calling the parse function 
 
 return (0); 
} 
 
 
 
Output: 
 
'int' IS A KEYWORD 
'a' IS A VALID IDENTIFIER 
'=' IS AN OPERATOR 
'b' IS A VALID IDENTIFIER 
'+' IS AN OPERATOR 
'1c' IS NOT A VALID IDENTIFIER